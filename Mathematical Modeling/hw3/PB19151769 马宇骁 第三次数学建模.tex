\documentclass[a4paper,AutoFakeBold,AutoFakeSlant]{ctexart}
\usepackage[a4paper,left=3cm,right=3cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{pythonhighlight}
\usepackage[mathscr]{eucal}
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{capt-of} 
\usepackage{hyperref} 
\usepackage{abstract}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{enumerate}
\usepackage{amsfonts} 
\usepackage{CJK,CJKnumb}
\usepackage{float}
\usepackage{gbt7714}
\usepackage{framed}


\newcommand{\song}{\CJKfamily{song}}    % 宋体   (Windows自带simsun.ttf)
\newcommand{\fs}{\CJKfamily{fs}}        % 仿宋体 (Windows自带simfs.ttf)
\newcommand{\kai}{\CJKfamily{kai}}      % 楷体   (Windows自带simkai.ttf)
\newcommand{\hei}{\CJKfamily{hei}}      % 黑体   (Windows自带simhei.ttf)
\newcommand{\li}{\CJKfamily{li}}        % 隶书   (Windows自带simli.ttf) 
\newcommand{\ssong}{\CJKfamily{STSong}}

\xeCJKsetup{SlantFactor = 0.3}
% \xeCJKsetup{SlantFactor = -0.7}
\setCJKmainfont[BoldFont=simhei.ttf, SlantedFont=simkai.ttf]{simsun.ttc}

% -- 中文字体 --
%\setCJKmainfont{Microsoft YaHei}  % 微软雅黑
%\setCJKmainfont{YouYuan}  % 幼圆
%\setCJKmainfont{NSimSun}  % 新宋体
%\setCJKmainfont{KaiTi}    % 楷体
% \setCJKmainfont{SimSun}   % 宋体
%\setCJKmainfont{SimHei}   % 黑体
% \setCJKfamilyfont{hwsong}{STSong}
 
% -- 英文字体 --
% \setmainfont{Times New Roman}
% \setmainfont{DejaVu Sans}
% \setmainfont{Latin Modern Mono}
% \setmainfont{Consolas}
% \setmainfont{Courier New}


\usepackage{xcolor}  	%高亮使用的颜色
\definecolor{commentcolor}{RGB}{85,139,78}
\definecolor{stringcolor}{RGB}{206,145,108}
\definecolor{keywordcolor}{RGB}{34,34,250}
\definecolor{backcolor}{RGB}{220,220,220}

\usepackage{accsupp}	
\newcommand{\emptyaccsupp}[1]{\BeginAccSupp{ActualText={}}#1\EndAccSupp{}}

\usepackage{listings}
\lstset{						%高亮代码设置
	language=python, 					%Python语法高亮
	linewidth=0.95\linewidth,      		%列表list宽度
	%basicstyle=\ttfamily,				%tt无法显示空格
	commentstyle=\color{commentcolor},	%注释颜色
	keywordstyle=\color{keywordcolor},	%关键词颜色
	stringstyle=\color{stringcolor},	%字符串颜色
	%showspaces=true,					%显示空格
	numbers=left,						%行数显示在左侧
	numberstyle=\tiny\emptyaccsupp,		%行数数字格式
	numbersep=5pt,						%数字间隔
	frame=single,						%加框
	framerule=0.1pt,						%划线
	escapeinside=@@,					%逃逸标志
	emptylines=1,						%
	xleftmargin=3em,					%list左边距
	backgroundcolor=\color{backcolor},	%列表背景色
	tabsize=4,							%制表符长度为4个字符
	% gobble=4							%忽略每行代码前4个字符
}




\renewcommand{\abstractname}{}    % clear the title
\renewcommand{\absnamepos}{empty}
%去除摘要两边缩进
\makeatletter
  \renewenvironment{abstract}{%
      \if@twocolumn
        \section*{\abstractname}%
      \else
        \small
        \begin{center}%
          {\bfseries \abstractname\vspace{-.5em}\vspace{\z@}}%
        \end{center}%
      \fi}
      {}
  \makeatother
  \lstset{
    language=Matlab,
    keywords={break,case,catch,continue,else,elseif,end,for,function,
       global,if,otherwise,persistent,return,switch,try,while},
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{dkgreen},
    stringstyle=\color{dkpurple},
    backgroundcolor=\color{white},
    tabsize=4,
    showspaces=false,
    showstringspaces=false
 }

\title{\textbf{\textsf{HW3} \heiti{数学建模报告}}}
\author{\ssong PB19151769~~~~~~马宇骁}
\date{}


\begin{document}


\maketitle


\begin{abstract}\zihao{-4} \kaishu
\noindent
\textbf{\heiti 摘要：} 以2020东京奥运会乒乓球项目底赛制作为分析背景，对乒乓球
参赛选手的排兵布阵进行建模，为比赛的选手安排提供理论指导。
\newline
\textbf{\heiti 关键词：}奥运会，乒乓球，对局分析，目标设定
\end{abstract}

\section{背景}
乒乓球项目的团体比赛中，需由教练员或
队长根据双方运动员的具体情况，预先安排各
自的出场阵容及顺序，然后运动员根据所安排
的顺序依次出场，进行以场为单位的回合制比
赛。因此，在这样的比赛中，赛前的排兵布阵尤
为关键。

谈及乒乓球团体比赛中排阵的重要性时，有
91. 3\%的教练员或运动员都认为在双方的实力
相近时，排阵的方案十分关键，甚至是起到决定
胜负的作用。\cite{张瑛秋2019东京奥运会乒乓球团体赛制改革背景下中国队夺金策略}

\subsection{赛制背景}
赛制以2020东京奥运会作为背景参考：

男单、女单比赛最多各70位选手参赛。排名前16的种子选手前两轮轮空，排名16至32位的选手首轮轮空。从第三轮开始，不再设轮空，比赛采用淘汰制。
混双比赛和团体赛均为16支球队参赛，比赛不设轮空，从第一轮开始极为淘汰制赛制。\cite{东京2020奥运观赛指南：乒乓球}

奥运会乒乓球有男子团体、女子团体、男子单打、女子单打、混合双打这五个比赛项目．
每个国家最多可以报名三名男选手和三名女选手，其中各有两名男/女选手参加单打，各
有至多一名男/女选手只参加团体不参加单打，至多一对混双选手，允许兼项．团体比赛
采取五场三胜制，第 2,3,4,5 场为单打，第 1 场为双打，每名运动员出场两次。
% 头号选手承
% 担两场单打，参加第 3 场比赛的选手只能参加一场单打．
% 假设我是乒乓球队总教练．考虑到兼项可能影响比赛成绩，分析如何设定参赛目标，并如
% 何报名
赛前两队抽签，确定主、客队。然后根据抽签的结果和对方可能出场的队员情况，开始分别确定出场阵容。

主队的3名运动员分别用A、B、C表示，客队的3名运动员分别用X、Y、Z表示。第1场为双打(BC－YZ)，第2场为单打(A－X)，第3场为单打(C－Z)，第4场为单打(A－Y)，第5场为单打(B－X)。该赛制要求各队在赛前通过抽签的方式确定主客队，随后根据选中的主队或是客队的出场顺序，确定A、B、C或X、Y、Z分别是哪一名运动员，然后按照规定的场次顺序进行比赛。
\subsection{中国背景}
乒乓球项目是我国竞技体育中的优势项
目，也是奥运会上的重点夺金项目。从 2008 年
北京奥运会上乒乓球项目加入了团体比赛起，
截至目前，中国队包揽了所有 3 届的冠军。

因此，此次建模是要最大可能让中国队获得金牌为目的进行分析。


\section{分析}

\subsection{混合双打}
2020东京奥运会开始第一次将混合双打作为奥运会正式项目纳入奥运章程，而且混双在很长周期内需要大量
练习配合参加各项赛事取得足够积分。但限于奥运会国家队总共只能带男女队员各3人（不考虑递补名额），因此
中国体育总局的安排是由男女队内3号选手组队参加混双（例如2020东京奥运会的许昕和刘诗雯组合）。

由于混双的比赛时间相比单打更早于团体赛，且他们不用参加单打，故混双不考虑参与较多的建模分析，且他们的体力损耗
在考虑计算时相应保留更多（见3.2.3的分析）。

\subsection{单打}
鉴于男子女子单打金牌是中国队必争的奖牌，除过2004年男单，在近几十年来该奖牌被中国队包揽。大满贯
（世锦赛，世界杯和奥运会）是每一位高水平的乒乓球运动员所追求的最高荣誉（例如2016里约奥运会最快大满贯荣誉的
张继科作为队内2号赛前带着腰伤打封闭的情况下国家队也并未使用递补名额，最终与马龙会师决赛惜败马龙未能取得男单历史上第一位双圈大满贯
的荣誉，马龙则获得男单历史上第一个全满贯荣誉）。

因此，考虑到本身的实力和运动员的荣誉，中国体育总局派出参加男子女子单打比赛的一直是男子女子队内1号与2号队员。他们分列上下半区，从八分之一决赛开打。

由于单打比赛决赛距离团体赛八分之一决赛时间间隔很短（2020东京奥运会的间隔为2天），因此此时需要考虑这4位选手的体力损耗。

\subsection{团体赛}
根据2018 年国际乒
联团体世界杯比赛期间对参赛的各国教练员或
运动员进行了访谈，共访谈 46 人( 其中教练员
22 人，运动员 24 人) ，访谈内容主要围绕乒乓
球团体比赛中排阵的重要性、排阵的关键因素、
排阵对比赛结果的影响等方面展开。\cite{张瑛秋2019东京奥运会乒乓球团体赛制改革背景下中国队夺金策略}
统计并整理访谈结果后，将被提及频率超过 50\%的词条陈列如下(表\ref{t1}):
\begin{table}[htbp]
  \begin{center}
  \setlength{\tabcolsep}{1.75mm}{
    \begin{tabular}{ccrr}
      \toprule 
      分类   & 词条  &  \multicolumn{1}{c}{被提及次数} & \multicolumn{1}{c}{提及频率/\%} \\
      \midrule
      排阵的重要性 & 双方实力相近时阵容非常关键 & 42  & 91.3 \\
       & 排阵时会有犹豫不决的情况出现 & 25 & 54.3 \\
      排阵的关键因素 & 了解对手的情况很重要 & 39  &  84.8\\
       & 教练员排阵的经验很重要 & 33  & 71.7 \\
       & 教练员排阵时候需要有胆魄 & 27  & 58.7 \\
       & 主客队选择很重要 & 26   & 56.5 \\
       排阵对比赛结果的影响 & 运动员的实力是胜负的关键 & 38  & 82.6 \\
       & 有时换个出场顺序比赛结果可能不一样 & 31   & 67.4 \\
  \bottomrule
  \end{tabular}}
  \caption{访谈结果——教练员与运动员对乒乓球团体比赛赛制的认识}
  \label{t1}
  \end{center}
  \end{table}

  在关于乒乓球团体比赛中排阵的关键因素的
访谈中，经归纳后被提及频率超过 50\% 的词
条有 4 个，分别是“了解对手的情况很重要”
“教练员排阵的经验很重要”“教练员排阵时
需要有胆魄”“主客队的选择很重要”。

由于主客队的选择是赛前抛硬币等随机手段决定，因此选择作为主队难以把握，故此时的排兵才是关键。

正如访谈结果所示，运动员的竞技实力
是影响比赛结果的重要因素，若某个队的实力
远远高于另一个队，那么比赛的结果肯定是明
确的，跟排阵不可能会有太大的关系。但也有
67. 4\%的教练员或运动员也提到，有时候若是
改变一下出场顺序，比赛的结果可能就会发生
改变。乒乓球团体比赛中的排阵对比赛结果是
有影响的，但要排除双方实力差距太大的情况。
实力稍高的队伍可能会因为没有排好阵容而输
了比赛，实力稍弱的队伍也可能会因为排的阵
容较好而取得胜利。


\section{建模}

\subsection{模型假设}
\begin{enumerate}
  \item 不存在伤病等突发因素使得比赛中断；
  \item 不考虑递补队员；
  \item 对弈双方均正常发挥；
  \item 双方均理性，即考虑自身胜率最大的排兵布阵。
\end{enumerate}

\subsection{模型建立}
建立排阵的模型需要一些数学和计算机的工具：

\subsubsection{能力值计算公式}

使用国际乒联（ITTF）官方数据库（2021.8）排位中的积分数据\cite{Rankings}作为能力值的原始数据(见图\ref{f1}, \ref{f2}).

由于男子和女子团体赛制相同，因此以下以男子团体比赛建模分析：

鉴于积分差距过大，且积分远大于0,因此在使用特征函数之前先将原始数据进行归一化再进行能力值转化。
取前16名的数据进行预处理。
\begin{equation}
  g_i = \frac{p_i - \mu}{\hat{\sigma}}
\end{equation}
其中$p_i$是原始积分数据。


此时考虑使用Sigmoid函数进行处理初步计算能力值：
\begin{equation}
  S(x) = \frac{1}{1 + e^{-x}}
\end{equation}
将数据映射到(0,1)的区间。
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{sig.pdf}
  \caption{Sigmoid函数}
  \label{f3}
\end{figure}

考虑到积分差距头部仍然过大，再对Sigmoid处理后的数据做修正arctan:
\begin{equation}
  S'(x) = \frac{arctan(x)}{\pi} + 0.5
\end{equation}
其中，x>=0，此时，绘图如下：
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{s2.pdf}
  \caption{修正arctan函数}
  \label{f4}
\end{figure}

中国队的三位选手樊振东、马龙和许昕能力值结果如下：
\begin{itemize}
  \item 0.7338804388095789
  \item 0.7315988916808487
  \item 0.7076299653921264
\end{itemize}

将积分前16名的能力值绘制如图\ref{f5}.
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{cap.pdf}
  \caption{能力值天梯图}
  \label{f5}
\end{figure}

看得出中国队的实力相比其他对手还是很高的。

% \newpage
\begin{figure}[htbp]
  \centering
  \begin{minipage}[t]{0.48\textwidth}
  \centering
  \includegraphics[width=6.5cm]{man.jpeg}
  \caption{男子单打世界排名}
  \label{f1}
  \end{minipage}
  \begin{minipage}[t]{0.48\textwidth}
  \centering
  \includegraphics[width=6.5cm]{woman.jpeg}
  \caption{女子单打世界排名}
  \label{f2}
  \end{minipage}
\end{figure}

\newpage
\subsubsection{python模拟比赛}
将对局分析分解为以下几个小步骤：
\begin{enumerate}
  \item 获得程序运行参数：probA（A的能力值）,probB（B的能力值）,n（比赛场次）
  \item 利用球员AB的能力值，模拟n场比赛
  \item 输出球员AB获胜的场次及概率
\end{enumerate}

利用对局规则：回合制，先由一方发球，如胜利，则得1分并继续发球，如失败，则双方分数不改变并交换球权。球员AB的能力为0-1之间的一个数值先得11分的一方为胜方；10平后，先多得2分的一方为胜方。
每颗球的对局采用随机数生成与“能力值”作比较决定得分。由此编程（见代码附录）传入双方能力值（双打则为队友能力值取平均），下方例子中然模拟进行100局（5局3胜制最多500轮），输出的各自胜率即为交手
双方对应的期望。

以樊振东和马龙为例，模拟结果如下：
\begin{framed}
  myx进行比赛分析结果：\\
  程序运行需要A和B的能力值（以0到1之间的小数表示）\\
  请输入A的能力值(0-1): 0.7338804388095789\\
  请输入B的能力值(0-1): 0.7315988916808487\\
  模拟比赛的场次: 100\\
  竞技分析开始，共模拟500场比赛\\
  A获胜287场比赛，占比57.4\%\\
  B获胜213场比赛，占比42.6\%  
\end{framed}

根据实际情况水平接近，该参数化方法分析模型是可行且优良的。
在建模中为了增加准确率使用1000局进行模拟。

\subsubsection{损耗}
由于赛制日程安排紧密，高水平高强度的比赛对于选手的体力的影响是不可忽视的。体力在一定程度上
会影响选手的发挥。
因此，对于既定收获了男单女单金银牌的四位选手在团体赛开打时的能力需要考虑做出削减。

不妨设历史损耗能力值：

冠亚军的能力只有理论值的90\%，每少打一轮损耗少2\%;
混双决赛的3号选手的能力为理论值的93\%，每少打一轮损耗少2.5\%（考虑到男女混双对
男选手的消耗比单打更大,女3为理论能力值的96.5\%，每少打一轮损耗少0.5\%）.

定义单场内损耗能力函数如下：

\begin{equation}
  Cap_{t_r} = Cap_{t_{r-1}}*\frac{1}{e^{0.1}}
\end{equation}
其中，$r$是运动员在一场团体赛中出场地轮数，$t$是第几场，$1 \leq t \leq 4$.

考虑到赛后一直到第二天的下一场体能少量恢复，因此两场比赛损耗能力函数定义为：
\begin{equation}
  Cap_{t} = Cap_{t-1}*0.95
\end{equation}

\subsubsection{优化筛选}
对理想情况进行枚举遍历过于复杂，因此，考虑使用MiniMax算法和$\alpha-\beta$剪枝简化筛选流程。

\begin{itemize}
  \item MiniMax算法
\end{itemize}

极小极大算法从当前状态计算极小极大策略。它使用了简单的递归算法计算每个后继的极小极大值，自上而下一直前进
到树的叶结点，然后随着递归回溯把极小极大值回转。\cite{aimethod}

总结一下Minimax算法的步骤：
\begin{enumerate}
  \item 首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。
  \item 在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。
  \item 自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。
  \item 每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。
\end{enumerate}

在模拟时，令中国队获胜的胜率拟合值为+，德国获胜的拟合值为-来计算每个节点对应的minimax值。

\begin{itemize}
  \item $\alpha-\beta$剪枝
\end{itemize}

将此技术应用到标准的极小极大搜索树上，会减掉那些不可能影响决策的分支，仍然返回和极小极大算法相同的结果。\cite{aimethod}
核心思想就是，当你知道你有一个选择A时，此时你知道了B选择不如A选择好，那么你就不需要知道B选择有多坏。
即对于一个结点MIN（敌人结点），若能估计出其倒推值的上界（遍历的值），若这个上界不大于（小于）MIN的父节点（最大收益），及时停止那些已无必要再扩展的结点。

至此，建模所需要的数学和计算机工具全部完成。

\subsection{具体单场完整建模——以男团决赛为例}
由于在决赛之前中国队的水平高于对手比较明显，因此，对于水平一般情况更为接近的决赛进行分析更能体现模型的价值。
当然，对于之前的每一场淘汰赛均可以使用该模型进行分析排阵。

由已经过去的2020东京奥运会男团决赛为例，决赛是中国队对决德国队，德国队的名单为：
奥恰洛夫，波尔, 弗朗西斯卡。

观察他们的当时世界排位，分别是：7, 10, 17。

中国队此时樊振东，马龙，许昕经过历史损耗能力值，马龙樊振东分获男单金银牌，许昕获得混双银牌，再由比赛损耗能力函数计算
他们的能力值为：
\begin{quote}
  0.48930480078482746, 0.48724162847976304, 0.48758183234964675
\end{quote}

德国队三人中，奥恰洛夫获得男单铜牌（与金银牌的比赛轮次数目相同损耗相同），波尔男单16强未进入八强少赛3轮，
弗朗西斯卡混双八强未进入半决赛少赛2轮，经过历史损耗能力值和比赛损耗能力函数计算得到：
\begin{quote}
  0.4366343392422034, 0.4344975963299249, 0.4203346107204399
\end{quote}

可见，虽然中国队仍然在实力上领先对手，但是经过比赛的损耗，此时的差距已经不是十分显著。

由此时的数据，考虑单场内损耗能力函数，暂不考虑实际情况如许昕是国乒双打王必然参加双打比赛。
因此，双方各有三种排兵方式，不妨令\{樊振东，马龙，许昕\}为\{1, 2, 3\}; \{奥恰洛夫，波尔, 弗朗西斯卡\}
为\{a, b, c\}.

% 由于受限于奥林匹克赛制（见背景1.1），因此共有$C^3_2*C^3_2 = 9$种情况。
手绘7层minimax树见图\ref{f6}.
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.25]{tree2.png}
  \caption{MiniMax树}
  \label{f6}
\end{figure}

以树的左侧分支分析筛选过程如下：

目的：使得根节点即中国队的获胜期望最大。

\begin{itemize}
  \item 第一场：双打
\end{itemize}

第一层：德国队有三种排法：ab,ac,bc. 对应的能力值为：
\begin{quote}
  0.43556596778606416, 0.4284844749813217, 0.42741610352518244
\end{quote}

第二层：左侧第一个分支对应中国队的三种排法：12,13,23. 对应的能力值为：
\begin{quote}
  0.4882732146322952, 0.4884433165672371, 0.48741173041470487
\end{quote}

暂时先不计算胜率期望，再向下遍历：

\begin{itemize}
  \item 第二场：单打
\end{itemize}

由于双打为规则中的B+C对Y+Z，因此，第二场的名单在第一场确定时已经确定。
此时，继续向下。（因此，考虑将这两层隐藏。）

\begin{itemize}
  \item 第三场：单打
\end{itemize}

第三层：因为双打只决定BC是谁，但具体谁是B谁是C仍然要讨论。德国队此时在\{12\}这颗子树上有两种选择：a,b.

第四层：同理，中国队在\{b\}这颗子树上有两种选择：1,2.

至此，ABC与XYZ三人对应的人已经确定，第四场第五场都已经确定。

\subsubsection{预计3场结束}
带入单场内损耗能力函数利用Minimax算法向上更新极大极小值，可以很快剪枝确定在第三层总共9个节点的选择如下：
\begin{quote}
12->c->3->b->2; \\
13->c->2->b->3; \\
23->c->1->b->2; \\
12->b->3->c->2; \\
13->b->2->c->3; \\
23->b->1->c->2; \\
12->a->3->c->2; \\
13->a->2->c->3; \\
23->a->1->c->2; 
\end{quote}

分别对应的中国队的期望值为： 0.7208000000000001, 0.6901999999999999, \\0.7475999999999999, 0.7263999999999999, 0.7398, 0.7388, 0.7432000000000001, 0.742, 0.7498

此时，选择最后一路树的枝作为max根节点，即：樊振东，马龙，许昕分别为ACB（XZY）。

\subsubsection{预计4场结束}
4场结束存在两种前提，中国队是主场和中国队是客场，区别在于主客场之间的第4,5场相互的对位是反过来的。

\begin{itemize}
  \item 若中国队抽到客场：
\end{itemize}

一共9层minimax树36个叶子结点，到第七层的max结点对应的值计算为：
\begin{quote}
  0.49859999999999993,
  0.513,
  0.5034000000000001,
  0.5073999999999999,
  0.5126,\\
  0.48200000000000004,
  0.491,
  0.5166,
  0.47540000000000004,
  0.5054,
  0.48899999999999993,
  0.5269999999999999,
  0.41800000000000004,
  0.4624,
  0.5064,
  0.49979999999999997,
  0.4168,
  0.42899999999999994,
  0.4998,
  0.5195999999999998,
  0.41280000000000006,
  0.41339999999999993,
  0.5124000000000001,
  0.48059999999999997,
  0.425,
  0.4226,
  0.4984,
  0.5028000000000001,
  0.441,
  0.42380000000000007,
  0.5146,
  0.5114000000000001,
  0.4272000000000001,
  0.42799999999999994,
  0.48200000000000004,
  0.5007999999999999
\end{quote}

继续向上更新，计算到第三层的MAX结点对应的值为：
 0.9976,
 1.0026000000000002,
 0.9954,
 0.9643999999999999,
 0.9465999999999999,
 0.9261999999999998,
 0.9851999999999999,
 1.0012,
 0.9376

故，此时，选择樊振东，马龙，许昕作为客队的YXZ选手上场比赛。与与预计3场结束的安排不一样。

\begin{itemize}
  \item 若中国队抽到主场：
\end{itemize}

第七层的max结点对应的值计算为：
\begin{quote}
  0.3926,
  0.41600000000000004,
  0.4418,
  0.4062000000000001,
  0.4098,
  0.4344000000000001,
  0.4444000000000001,
  0.41080000000000005,
  0.40740000000000004,
  0.42080000000000006,
  0.427,
  0.4184,
  0.5056,
  0.49240000000000006,
  0.5118,
  0.4864,
  0.47900000000000004,
  0.5104,
  0.5137999999999999,
  0.47580000000000006,
  0.5056,
  0.4872,
  0.49539999999999995,
  0.5118,
  0.4818,
  0.48179999999999995,
  0.49240000000000006,
  0.5254000000000001,
  0.49520000000000003,
  0.502,
  0.5278,
  0.48739999999999994,
  0.508,
  0.5191999999999999,
  0.5304,
  0.5065999999999999
\end{quote}

继续向上更新，计算到第三层的MAX结点对应的值为：
 0.9032,
 0.9510000000000001,
 0.9242,
 0.9538000000000001,
 0.9402,
 0.9766000000000001,
 0.9383999999999999,
 0.9708,\\
 0.9813999999999999

故，此时，选择樊振东，马龙，许昕作为主队的ACB选手上场比赛。这个安排与预计3场结束的安排是一样的。

\subsubsection{预计5场结束}
5场结束在计算的时候主客场对于结果是不存在影响到，因为两场互换顺序的比赛都在最后4层单支的树结构上，
相加时不影响结果。

第七层的max结点对应的值计算为：
\begin{quote}
  0.9092,
 0.895,
 0.9352,
 0.9196,
 0.9072,
 0.9141999999999999,
 0.9346000000000001,
 0.9128000000000001,
 0.9322,
 0.9324000000000001,
 0.9281999999999999,\\
 0.9335999999999999,
 0.9345999999999999,
 0.9234,
 0.9724,
 0.9702000000000002,\\
 0.9099999999999999,
 0.9298,
 0.9747999999999999,
 1.01,
 0.9128000000000001,\\
 0.8904000000000001,
 1.0168,
 1.0116,
 0.9401999999999999,
 0.8997999999999999,\\
 1.0221999999999998,
 0.9924,
 0.9432,
 0.9426000000000001,
 1.0286,
 1.017,
 0.922,
 0.9417999999999999,
 0.9978,
 1.0156
\end{quote}

继续向上更新，计算到第三层的MAX结点对应的值为：
1.4308,
 1.4382000000000001,
 1.4412,
 1.4578000000000002,
 1.4252,
 1.4702,
 1.4349999999999998,
 1.4777999999999998,\\
 1.4662000000000002

由minimax计算结果可以看出，此时安排樊振东，马龙，许昕作为BAC（YXZ）选手上场比赛。

\subsection{建模结果分析}
从对2020东京奥运会乒乓球男子团体决赛的建模过程中可以看出，对于想要在几场拿下比赛，派出的人员序列是
不一样的。从当时的赛况结果看，中国队抽到主队，最终以3：0战胜德国队卫冕成功。当时主教练排出的阵型就是：
\begin{enumerate}[A.]
  \item 樊振东
  \item 马龙
  \item 许昕
\end{enumerate}
与建模过程中分析的预计3场结束的阵容完全相同，也与预计4场结束中国队抽到主队的情况相同。证明模型效果十分好！
与建模对比，主教练也应该是没有想要去进行5场比赛，也想尽可能最快拿到金牌。

\section{结论}
通过积分量化能力值并使用minimax进行对局分析，主教练在选手均正常发挥的情况下只需要将对手和
本方队员的数据进行拟合，根据自己预想几场完赛就可以得到非常合适的不同对策。这大大提高了主教练
的变阵可靠性和分析的准确性。

根据具体人员，比如说选手在双打的契合度惯用手的匹配度，还可以在计算能力值的
时候对这些特征再做加分加权使得该模型更准确好用。

回看文献中的统计记录\cite{张瑛秋2019东京奥运会乒乓球团体赛制改革背景下中国队夺金策略}：



% 由于深度D可能达到终局，也可能是一个中间格局，考虑到可能3场结束比赛，4场结束比赛和5场结束比赛的布阵不一样，因此分类讨论。

% \subsubsection{3场结束}
% 3场结束则应该刚刚好对应图\ref{f6},计算

% \subsubsection{第一场：双打}
% \begin{enumerate}
%   \item 
% \end{enumerate}


\section*{代码附录}
部分Python代码展示如下：
\begin{python}
from numpy import *
l = [12494,12212,10356,8709,8375,8034,7999,7864,7357,7086,6723,6531,6485,5995,5871,5841,5822,5623,5538,5487,5482,5023,4673,4650,4557,4469,4384,4214,4175,4122,4113,4056]
p = [12494,12212,10356,8709,8375,8034,7999,7864,7357,7086,6723,6531,6485,5995,5871,5841]
g = [(i-mean(p))/std(p) for i in l]


import matplotlib.pyplot as plt
import numpy as np
  
def sigmoid(x):
    # 直接返回sigmoid函数
    return 1. / (1. + np.exp(-x))
  
# param:起点，终点，间距
x = np.arange(-8, 8, 0.05)
y = sigmoid(x)
plt.plot(x, y)
plt.savefig('sig.pdf')
plt.show()

s = [sigmoid(i) for i in g]
def at(x):
    y = np.arctan(x)/np.pi + 0.5
    return y
x = np.arange(0, 8, 0.05)
z = at(x)
plt.plot(x, z)
plt.savefig('s2.pdf')
plt.show()

ss = [np.arctan(i)/np.pi + 0.5 for i in s]

fig, ax = plt.subplots()
b = ax.barh(range(1,len(s)+1),s)
ax.set_yticks(range(1,len(s)+1))
# ax.set_yticklabels(s.index)
plt.savefig('cap.pdf')
plt.show()
\end{python}

\begin{python}
  ## 演示代码如下
from random import random 
def printIntro():          #打印程序介绍信息
    print("myx进行比赛分析结果：")
    print("程序运行需要A和B的能力值（以0到1之间的小数表示）")
def getInputs():           #获得程序运行参数
    a = eval(input("请输入A的能力值(0-1): "))
    b = eval(input("请输入B的能力值(0-1): "))
    n = eval(input("模拟比赛的场次: "))
    return a, b, n
def simNGames(n, probA, probB):    # 进行N场比赛
    winsA, winsB = 0, 0
    for i in range(n):
        for j in range(5):           #进行5局3胜的比赛
            scoreA, scoreB = simOneGame(probA, probB)
            if scoreA > scoreB:
                winsA += 1
            else:
                winsB += 1
    return winsA, winsB
def gameOver(a,b):               #正常比赛结束
    return a==11 or b==11
def gameOver2(a,b):              #进行抢12比赛结束
    return a==12 or b==12
def simOneGame(probA, probB):         #进行一场比赛
    scoreA, scoreB = 0, 0           #初始化AB的得分
    serving = "A"                 
    while not gameOver(scoreA, scoreB):     #用while循环来执行比赛
        if scoreA==10 and scoreB==10:
            return(simtwoGame2(probA,probB))
        if serving == "A":
            if random() < probA:            ##用随机数生成胜负
                scoreA += 1
            else:
                serving="B"
        else:
            if random() < probB:
                scoreB += 1
            else:
                serving="A"
    return scoreA, scoreB
def simtwoGame2(probA,probB):
    scoreA,scoreB=10,10
    serving = "A"                 #假如先让队伍A发球
    while not gameOver2(scoreA, scoreB):
        if serving == "A":
            if random() < probA:
                scoreA += 1
            else:
                serving="B"
        else:
            if random() < probB:
                scoreB += 1
            else:
                serving="A"
    return scoreA, scoreB
def printSummary(winsA, winsB):
    n = winsA + winsB
    print("竞技分析开始，共模拟{}场比赛".format(n))
    print("A获胜{}场比赛，占比{:0.1%}".format(winsA, winsA/n))
    print("B获胜{}场比赛，占比{:0.1%}".format(winsB, winsB/n))

def main():
    printIntro()  
    probA, probB, n = getInputs()
    winsA, winsB = simNGames(n, probA, probB)
    printSummary(winsA, winsB)
main()
  ##多轮模拟时修改取消print的内容和传参方式
\end{python}

\begin{python}
  l1 = [i for i in ss[:3]]
  l2 = [ss[6],ss[9],ss[16]]
  l1[0] = l1[0]*.9
  l1[1] = l1[1]*.9
  l1[2] = l1[2]*.93
  l2[0] = l2[0]*0.9
  l2[1] = l2[1]*0.96
  l2[2] = l2[2]*0.98
  l1 = [i/(exp(0.1*3)) for i in l1]
  l2 = [i/(exp(0.1*3)) for i in l2]

def lose(a,b,n=100):
  # printIntro()
  probA, probB, n = a,b,n
  winsA, winsB = simNGames(n, probA, probB)
  return -winsA/(winsA + winsB)
def win(a,b,n=100):
  # printIntro()
  probA, probB, n = a,b,n
  winsA, winsB = simNGames(n, probA, probB)
  return winsB/(winsA + winsB)
def expt(a,b,n=100):
  e = win(a,b,n) + lose(a,b,n)
  return e

cap1 = [(l1[0]+l1[1])/2,(l1[0]+l1[2])/2,(l1[1]+l1[2])/2]
cap2 = [(l2[0]+l2[1])/2,(l2[0]+l2[2])/2,(l2[1]+l2[2])/2]

def loss(x,r=1):
    x = x/exp(0.1*r)
    return x

r1 = expt(cap2[0],cap1[0])+expt(l2[2],l1[2])+expt(loss(l2[1]),loss(l1[1]))
r2 = expt(cap2[0],cap1[1])+expt(l2[2],l1[1])+expt(loss(l2[1]),loss(l1[2]))
r3 = expt(cap2[0],cap1[2])+expt(l2[2],l1[0])+expt(loss(l2[1]),loss(l1[1]))
r1 = expt(cap2[1],cap1[0])+expt(l2[1],l1[2])+expt(loss(l2[2]),loss(l1[1]))
r2 = expt(cap2[1],cap1[1])+expt(l2[1],l1[1])+expt(loss(l2[2]),loss(l1[2]))
r3 = expt(cap2[1],cap1[2])+expt(l2[1],l1[0])+expt(loss(l2[2]),loss(l1[1]))
r1 = expt(cap2[2],cap1[0])+expt(l2[0],l1[2])+expt(loss(l2[2]),loss(l1[1]))
r2 = expt(cap2[2],cap1[1])+expt(l2[0],l1[1])+expt(loss(l2[2]),loss(l1[2]))
r3 = expt(cap2[2],cap1[2])+expt(l2[0],l1[0])+expt(loss(l2[2]),loss(l1[1]))

ll1 = [loss(i) for i in l1]
ll2 = [loss(i) for i in l2]
r = []
r.append(expt(ll2[0],ll1[0])+expt(ll2[2],ll1[1]))
r.append(expt(ll2[0],ll1[1])+expt(ll2[2],ll1[0]))
r.append(expt(ll2[1],ll1[0])+expt(ll2[2],ll1[1]))
r.append(expt(ll2[1],ll1[1])+expt(ll2[2],ll1[0]))
r.append(expt(ll2[0],ll1[0])+expt(ll2[2],ll1[2]))
r.append(expt(ll2[0],ll1[2])+expt(ll2[2],ll1[0]))
r.append(expt(ll2[1],ll1[0])+expt(ll2[2],ll1[2]))
r.append(expt(ll2[1],ll1[2])+expt(ll2[2],ll1[0]))
r.append(expt(ll2[0],ll1[1])+expt(ll2[2],ll1[2]))
r.append(expt(ll2[0],ll1[2])+expt(ll2[2],ll1[1]))
r.append(expt(ll2[1],ll1[2])+expt(ll2[2],ll1[2]))
r.append(expt(ll2[1],ll1[2])+expt(ll2[2],ll1[1]))
r.append(expt(ll2[0],ll1[0])+expt(ll2[1],ll1[1]))
r.append(expt(ll2[0],ll1[1])+expt(ll2[1],ll1[0]))
r.append(expt(ll2[2],ll1[0])+expt(ll2[1],ll1[1]))
r.append(expt(ll2[2],ll1[1])+expt(ll2[1],ll1[0]))
r.append(expt(ll2[0],ll1[0])+expt(ll2[1],ll1[2]))
r.append(expt(ll2[0],ll1[2])+expt(ll2[1],ll1[0]))
r.append(expt(ll2[2],ll1[0])+expt(ll2[1],ll1[2]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[1],ll1[0]))
r.append(expt(ll2[0],ll1[1])+expt(ll2[1],ll1[2]))
r.append(expt(ll2[0],ll1[2])+expt(ll2[1],ll1[1]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[1],ll1[2]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[1],ll1[1]))
r.append(expt(ll2[1],ll1[0])+expt(ll2[0],ll1[1]))
r.append(expt(ll2[1],ll1[1])+expt(ll2[0],ll1[0]))
r.append(expt(ll2[2],ll1[0])+expt(ll2[0],ll1[1]))
r.append(expt(ll2[2],ll1[1])+expt(ll2[0],ll1[0]))
r.append(expt(ll2[1],ll1[0])+expt(ll2[0],ll1[2]))
r.append(expt(ll2[1],ll1[2])+expt(ll2[0],ll1[0]))
r.append(expt(ll2[2],ll1[0])+expt(ll2[0],ll1[2]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[0],ll1[0]))
r.append(expt(ll2[1],ll1[1])+expt(ll2[0],ll1[2]))
r.append(expt(ll2[1],ll1[2])+expt(ll2[0],ll1[1]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[0],ll1[2]))
r.append(expt(ll2[2],ll1[2])+expt(ll2[0],ll1[1]))
rr = []
for i in range(len(r)//2):
    rr.append(min(r[2*i],r[2*i+1]))
rrr = []
for i in range(len(rr)//2):
    rrr.append(max(rr[2*i],rr[2*i+1]))

r4 = []
cnt = 0
for i in range(2,-1,-1):
    for j in range(2,-1,-1):
        r4.append(expt(l2[i],l1[j])+rrr[cnt])
        cnt += 1
r5 = []
cnt = 0
for i in range(3):
    for j in range(3):
        r5.append(expt(cap2[i],cap1[j])+r4[cnt])
        cnt += 1
\end{python}



% \bibliographystyle{gbt7714-numerical}
\bibliography{bibl}

\end{document}